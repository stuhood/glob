var N=null,E="",T="t",U="u",searchIndex={};
var R=["Return an iterator that produces all the `Path`s that…","result","patternerror","Return if the given `str` matches this `Pattern` using the…","matchoptions","Return if the given `Path`, when converted to a `str`,…","string","try_from","borrow","type_id","borrow_mut","try_into","to_string","to_owned","clone_into","typeid","pattern","partial_cmp","ordering","formatter","description","PatternError","MatchOptions","GlobError"];

searchIndex["glob"]={"doc":"Support for matching file paths against Unix shell style…","i":[[3,"Paths","glob","An iterator that yields `Path`s from the filesystem that…",N,N],[3,R[23],E,"A glob iteration error.",N,N],[3,R[21],E,"A pattern parsing error.",N,N],[12,"pos",E,"The approximate character index of where the error occurred.",0,N],[12,"msg",E,"A message describing the error.",0,N],[3,"Pattern",E,"A compiled Unix shell style pattern.",N,N],[3,R[22],E,"Configuration options to modify the behaviour of…",N,N],[12,"case_sensitive",E,"Whether or not patterns should be matched in a…",1,N],[12,"require_literal_separator",E,"Whether or not path-component separator characters (e.g.…",1,N],[12,"require_literal_leading_dot",E,"Whether or not paths that contain components that start…",1,N],[5,"glob",E,R[0],N,[[["str"]],[R[1],["paths",R[2]]]]],[5,"glob_with",E,R[0],N,[[["str"],[R[4]]],[R[1],["paths",R[2]]]]],[6,"GlobResult",E,"An alias for a glob iteration result.",N,N],[11,"path",E,"The Path that the error corresponds to.",2,[[["self"]],["path"]]],[11,"error",E,"The error in question.",2,[[["self"]],["error"]]],[11,"into_error",E,"Consumes self, returning the raw underlying `io::Error`",2,[[["self"]],["error"]]],[11,"new",E,"This function compiles Unix shell style patterns.",3,[[["str"]],[R[1],[R[2]]]]],[11,"escape",E,"Escape metacharacters within the given string by…",3,[[["str"]],[R[6]]]],[11,"matches",E,R[3],3,[[["self"],["str"]],["bool"]]],[11,"matches_path",E,R[5],3,[[["self"],["path"]],["bool"]]],[11,"matches_with",E,R[3],3,[[["self"],["str"],[R[4]]],["bool"]]],[11,"matches_path_with",E,R[5],3,[[["self"],["path"],[R[4]]],["bool"]]],[11,"as_str",E,"Access the original glob pattern.",3,[[["self"]],["str"]]],[11,"new",E,"Constructs a new `MatchOptions` with default field values.…",1,[[],["self"]]],[11,"into",E,E,4,[[["self"]],[U]]],[11,"into_iter",E,E,4,[[["self"]],["i"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[7],E,E,4,[[[U]],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[R[15]]]],[11,R[10],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[1]]]],[11,"into",E,E,2,[[["self"]],[U]]],[11,R[12],E,E,2,[[["self"]],[R[6]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[7],E,E,2,[[[U]],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[R[15]]]],[11,R[10],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[1]]]],[11,"into",E,E,0,[[["self"]],[U]]],[11,R[12],E,E,0,[[["self"]],[R[6]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[7],E,E,0,[[[U]],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[R[15]]]],[11,R[10],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[1]]]],[11,"into",E,E,3,[[["self"]],[U]]],[11,R[13],E,E,3,[[["self"]],[T]]],[11,R[14],E,E,3,N],[11,R[12],E,E,3,[[["self"]],[R[6]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[7],E,E,3,[[[U]],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[R[15]]]],[11,R[10],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[1]]]],[11,"into",E,E,1,[[["self"]],[U]]],[11,R[13],E,E,1,[[["self"]],[T]]],[11,R[14],E,E,1,N],[11,"from",E,E,1,[[[T]],[T]]],[11,R[7],E,E,1,[[[U]],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[R[15]]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[1]]]],[11,R[17],E,E,3,[[["self"],[R[16]]],["option",[R[18]]]]],[11,"lt",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,"le",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,"gt",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,"ge",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,R[17],E,E,1,[[["self"],[R[4]]],["option",[R[18]]]]],[11,"lt",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"le",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"gt",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"ge",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"next",E,E,4,[[["self"]],["option",["globresult"]]]],[11,"eq",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,"ne",E,E,3,[[["self"],[R[16]]],["bool"]]],[11,"eq",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"ne",E,E,1,[[["self"],[R[4]]],["bool"]]],[11,"default",E,E,3,[[],[R[16]]]],[11,"default",E,E,1,[[],[R[4]]]],[11,"clone",E,E,3,[[["self"]],[R[16]]]],[11,"clone",E,E,1,[[["self"]],[R[4]]]],[11,"cmp",E,E,3,[[["self"],[R[16]]],[R[18]]]],[11,"cmp",E,E,1,[[["self"],[R[4]]],[R[18]]]],[11,"fmt",E,E,2,[[["self"],[R[19]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[19]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[19]]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[19]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[19]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[19]]],[R[1]]]],[11,"hash",E,E,3,N],[11,"hash",E,E,1,N],[11,"from_str",E,E,3,[[["str"]],[R[1],[R[2]]]]],[11,R[20],E,E,2,[[["self"]],["str"]]],[11,"cause",E,E,2,[[["self"]],["option",["error"]]]],[11,R[20],E,E,0,[[["self"]],["str"]]]],"p":[[3,R[21]],[3,R[22]],[3,R[23]],[3,"Pattern"],[3,"Paths"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);